SESSION-1: STRUCTURAL ADDER.

Make half-adder, full adder using gate descriptions. Show waveform output and RTL design generated by Xilinx. Write test-bench for each and show output on waveform. Also try “$monitor” command to generate values of output from the testbench. Complete 4-bit ripple carry and show at the beginning of next lab.

SESSION-2: RIPPLE-CARRY – DELAY ANALYSIS

Implement a 4-bit ripple carry adder with gate delays: output sum and cout are generated after 2ns each. Thus answer for first bit comes after 2ns. Answer for second bit comes after 4ns and so on.

A 4-bit ripple carry must give output after 8ns. Try various testcases and use monitor stmt to check the timing of final output generation. Find the testcase which gives the worst case delay.

Ripple carry adders are slow due to the ripple effect. Therefore, Carry Look Ahead adders are better. Write the code for CLA adder for 4-bit and check the timings. Use equations for CLA logic that give out Pi and Gi for propagate and generate inputs. Each level of logic has 1ns delay. For example, if you have out= (a&b) | (c&d), then you have 2-level logic that uses AND gates followed by OR. So the delay for this will be 2ns.

Comment on which type of adder is good and when and why. Demonstrate your answer.

SESSION-3:

MUX

=====

Design a 4x1 MUx using following type of stmts:

Output = equations for AND-gates that are inside the mux. Inputs are i0,i1,i2,i3 and select=s1,s0.

Also write output = conditional assignment

Cond ? : stmt-1 : stmt-2

Synthesise both types are check the difference in RTL schematic. Also read the design summary generated and see if the final designs are different or not.

ALU

====

Design 4-bit ALU:

The 4-bit ALU has the following inputs:

A: 4-bit, B: 4-bit , Cin: 1-bit, Control: 3-bit control input

Output: ANS: 4-bit, Cout: 1-bit

Control Instruction Operation

000 ADD Output <= A + B + Cin; Cout contains the carry

001 SUB Output <= A – B - Cin; Cout contains the borrow

010 OR Output <= A or B

011 AND Output <= A and B

100 SHL Output <= A[2:0] & ‘0’

101 SHR Output <= ‘0’ & A[3:1]

110 ROL (Rotate left) Output <= A[2:0] & A[3]

111 ROR (Rotate right) Output <= A[0] & A [3:1]

Use 'case' statement. Design is purely combinational. Output should change as soon as any input or control combination changes.

Subtraction function must give the correct answer and indicate overflows.

Make sure there are no latches in the synthesised design (RTL schematic).

Try removing one case from the ‘case’ stmt and see the RTL. Compare the RTL with all case options. Identify the difference.

How many MUX are there in your RTL? 1 or 2? What is their purpose?

SESSION-4:

(1)

Design a 3-bit register using a serial input “a”. Input goes to first flip-flop (d0). Output of do which is q0 goes as input to second flip-flop d1-q1. Output of second flip-flop goes to third one d3-q3.

take inputs as d0,d1,d2 and outputs as q0,q1,q2. Don't take multibit registers.

Design using an always @clk statement.

(i) Change the order of your assignments within the always blocks.

(ii) Also implement the block statements using “<=” as assignment operator instead of “=”.

(ii) For both type of assignment operators and all possible reordering of stmts in always block check the RTL generated. Is it same or different?

(iv) Also check the “synthesis report” in the “design summary” and find out delay of our circuit under “HDL synthesis”.

(2)

Take multi-bit inputs and outputs d0-d3 and q0-q3. Design 4-bit register. that has LOAD and CLEAR as control inputs. CLEAR input has priority over LOAD.

Use parallel load feature.

Write appropriate testbench and show that CLEAR has priority.

Testbench mush generate CLK as a continuous waveform.

SESSION-5:

(1)
First make a 4-bit register with LOAD, CLEAR features.
Test it by loading and clearing at random time intervals.
Test-case will have CLK generated using for-loop.

 
Use the above register and change it to a up-counter. There is additional input INCR.
If counter is enabled then it increments.
Clear has priority. Then Load has priority. Increment happens when counter is enabled.
Write elaborate test-cases to demonstrate all features.

Timing at which inputs should change can be varied across the clock period.
Try to be innovative and design test cases with interesting timings so as to demonstrate the design and priorities.


 (2)
Cascade the above counter with another one to generate a 8-bit up-counter.
You have to use the above 4-bit counter as a module for this design.

Make necessary changes in the 4-bit version if required.
Write proper test-cases.
Be innovative in your test cases and timing delays inserted for various combinations.
